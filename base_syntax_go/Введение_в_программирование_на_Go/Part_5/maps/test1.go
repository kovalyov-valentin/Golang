//Посмотрим на пример программы, использующей карты:

package main

import "fmt"

func main() {
    elements := make(map[string]string)
    elements["H"] = "Hydrogen"
    elements["He"] = "Helium"
    elements["Li"] = "Lithium"
    elements["Be"] = "Beryllium"
    elements["B"] = "Boron"
    elements["C"] = "Carbon"
    elements["N"] = "Nitrogen"
    elements["O"] = "Oxygen"
    elements["F"] = "Fluorine"
    elements["Ne"] = "Neon"

    fmt.Println(elements["Li"])
}

В данном примере elements - это карта, которая представляет 10 первых химических элементов, индексируемых символами. 
Это очень частый способ использования карт — в качестве словаря или таблицы. 
Предположим, мы пытаемся обратиться к несуществующему элементу:

fmt.Println(elements["Un"])

Если вы выполните это, то ничего не увидите. Технически карта вернет нулевое значение хранящегося типа (для строк это пустая строка). 
Несмотря на то, что мы можем проверить нулевое значение с помощью условия (elements["Un"] == ""), в Go есть лучший способ сделать это:

name, ok := elements["Un"]
fmt.Println(name, ok)

Доступ к элементу карты может вернуть два значения вместо одного. Первое значение это результат запроса, второе говорит, был ли запрос успешен. 
В Go часто встречается такой код:

if name, ok := elements["Un"]; ok {    
    fmt.Println(name, ok)
}
Сперва мы пробуем получить значение из карты, а затем, если это удалось, мы выполняем код внутри блока.
