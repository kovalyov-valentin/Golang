// // Функция хэширования принимает набор данных и уменьшает его до фиксированного размера.
// // Хэши используются в программировании повсеместно, начиная от поиска данных, заканчивая быстрым детектированием измененний.
// // Хэш-функции в Го подразделяются на две категории:
// // криптографические и некриптографические.

// // Некриптографические функции можно найти в пакете hash, 
// // который включает такие алгоритмы как adler32, crc32, crc64 и fnv. 
// // Пример использования crc32:

// package main

// import (
// 	"fmt"
// 	"hash/crc32"
// )
// func main() {
// 	h := crc32.NewIEEE()
// 	h.Write([]byte("test"))
// 	v := h.Sum32()
// 	fmt.Println(v)
// }

// // Объект crc32 реализует интерфейс Writer, так что мы можем просто записать в него набор байт, как и влюбой другой Writer.
// // После записи мы вызываем Sum32(), который вернет uint32.
// // Обычным применением crc32 является сравнение двух файлов.
// // Если значение Sum32() для обоих файлов одинаково, то, весьма вероятно( но не со стопроцентной гарантией), содержимое этих файлов идентично.
// // Если же значения отличаются, значит файлы, безусловно, разные: 

// package main

// import (
// 	"fmt"
// 	"hash/crc32"
// 	"io/ioutil"
// )
// func getHash(filename string) (uint32, error) {
// 	bs, err := ioutil.ReadFile(filename)
// 	if err != nil {
// 		return 0, err 
// 	}
// 	h := crc32.NewIEEE()
// 	h.Write(bs)
// 	return h.Sum32(), nil
// }
// func main() {
// 	h1, err := getHash("test1.txt")
// 	if err != nil {
// 		return
// 	}
// 	h2, err := getHash("test2.txt")
// 	if err != nil {
// 		return
// 	}
// 	fmt.Println(h1, h2, h1 == h2)
// }

// // Криптографические хэш-функции аналогичны их некриптографическим коллегам, однако у них есть одна особенность: их сложно обратить вспять.
// // Очень сложно определить, что за набор данных содержится в криптографическом хэше, поэтому такие хэши часто используются в системах безопасности.

// // Одним из криптографческих хэш-алгоритвом является SHA-1.
// // Его можно использовать следующим образом:

// package main 

// import (
// 	"fmt"
// 	"crypto/sha1"
// )
// func main() {
// 	h := sha1.New()
// 	h.Write([]byte("test"))
// 	bs := h.Sum([]byte{})
// 	fmt.Println(bs)
// }

// // Этот пример очень похож на пример использования crc32, потому что они оба реализуют интерфейс hash.Hash.
// // Основное отличие в том, что в то время как crc32 вычисляет 32-битный хэш, sha1 вычисляет 160-битный хэш.
// // В Го нет встроенного типа для хранения 160-битного числа, поэтому вместо него мы используем срез размером 20 байт.
