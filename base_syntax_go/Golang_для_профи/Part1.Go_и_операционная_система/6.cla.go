// Работа с аргументами командной строки

// Эта программа находит минимальный и максимальный из своих аргументов командной строки.
package main 

import (
	"fmt"
	"os" // Чтобы программа получала аргументы командной строки, нужно использовать пакет os 
	"strconv" // Этот пакет дает возможность преобразовывать аргументы командной строки, заданные в виде строк, в арифметический тип данных.
)
func main() {
	if len(os.Args) == 1 { /* Контролируя длину os.Args программа проверяет есть ли у нас аргументы командной строки.
	Так как для работы программы необходим как минимум один аргумент команднйо строки.
	Следует обратить внимание, что os.Args это срез, содержащий значения типа string 
	Первы элемент среза - это имя исполняемой программы.
	Поэтому, чтобы инициализировать переменные min и max, нужно использовать второй элемент среза os.Args, имеющий тип string, индекс которого равен 1.
	*/
		fmt.Println("Please give one or more floats.")
		os.Exit(1)
	}

	arguments := os.Args 
	min, _ := strconv.ParseFloat(arguments[1], 64) /* Наша программа игнорирует значение типа error, возвращаемое strconv.ParseFloat() 
	Оператор говорит, что мы хотим получить только первое значение, возвращаемое функцией strconv.ParseFloat(), и что нас не интересует второе, которое в данном случае является переменной типа error - присваиваем это значение символу подчеркивания.
	*/
	max, _ := strconv.ParseFloat(arguments[1], 64)

	for i := 2; i < len(arguments); i++ { // Здесь цикл for позволяет перебрать все элементы среза os.Args, который перед этим был присвоен переменной arguments
		n, _ := strconv.ParseFloat(arguments[i], 64)
		
		if n < min {
			min = n 
		} 
		if n > max {
			max = n
		}
	}
	fmt.Println("Min:", min)
	fmt.Println("Max:", max)
}
// В итоге если на вход подать ошибочные данные, что программа начнет себя некорректно. И не выводится никаких предупреждений об ошибках. Это произойдет если смешать буквы и числа.