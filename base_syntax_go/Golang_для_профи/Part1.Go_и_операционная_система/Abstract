Препроцессор - это программа, которая обрабатывает входные данные и генерирует выходные данные, которые будут использоваться в качестве входных для другой программы.
В контексте языков программирования входные данные препроцессора - это исходный код программы, который будет обработан препроцессором и затем передан на вход компилятора языка программмирования.

Утилита godoc позволяет просматривать документацию загруженных фукций и пакетов Go.



Стандартные потоки UNIX: stdin, stdout и stderr
В любой ОС UNIX есть три файла, которые постоянно открыты для своих процессов.
В качестве внутреннего представления для доступа ко всем открым файлам UNIX использует файловые дескрипторы - положительные целые числа.
По умолчанию любая UNIX-система поддерживает три специальных стандартных имени файла:
    /dex/stdin
    /dex/stdout
    /dev/stderr 
К ним также можно получить доступ, используя файловые дескрипторы 0, 1 и 2 соответственно.
Эти три файловых дескриптора называют стандартными потоками ввода, вывода и ошибок соответсвенно.
Go использует:
    os.Stdin (стандартный поток ввода) 
    os.Stdout (поток вывода)
    os.Stderr (поток ошибок)



Вывод результатов
fmt.Println() автоматически добавляет в конец вывода символ новой строки.
В fmt.Printf() нужно указывать спецификатор формата, для всего, что хотите вывести на экран.
В Go эти спецификаторы называются глаголами.
fmt.Print(), fmt.Println() и fmt.Printf() являются простейшими функциями для вывода данных на экран.
Существуют также семейство S-функций, они используются для построения строк по заданному формату.
Существует семейство F-функций, они используются для записи в файлы с помощью io.Writer.



Использование стандартного потока вывода
Стандартный поток вывода более менее эквивалентен выводу на экран.
Иногда от требует применение функций не входящих в пакет fmt.



Получение данных от пользователя
Есть три основных способа получения данных от пользователя:
    Прочитать аргументы командной строки программы 
    Предложить пользователю ввести данные 
    Прочитать внешние файлы 


Символ подчеркивания _ называется пустым идентификатором и является средством сброса значения в Go.


Запись в журнальные файлы 
Пакет log позволяет отправлять журнальные сообщения в системную службу журналирования.
Пакет syslog, который является частью пакета log, позволяет определить уровень журналирования и средство журналирования, которое будет использовать программа.
Большинство системных журнальных файлов размещаются в каталоге /var/log. 
Вообще, использование журнальных файлов для записи некоторой информации считается более эффективной практикой, чем вывод тех же данных на экран.
На это есть две причины:
    Во-первых,Выходные данные, сохраняемые в файле не теряются 
    Во-вторых, потому, что вы можете вести поиске и обрабатывать файлы журналов с помощью UNIX-инструментов, как grep(1), awk(1), sed(1); если же сообщения выводятся в окне терминала, это невозможно.
Пакет log предлагает множество функций для перенаправления вывода в системную службу журналирования.
    В число этих функций входят: log.Printf(), log.Print(), log.Println(), log.Fatalf(), log.Fatalln(), log.Panic(), log.Panicl(), log.Panicf().
СЛЕДУЕТ ОБРАТИТЬ ВНИМАНИЕ, функции журналирования могут быть очень полезны при отладке программ, особенно написанных на Go серверных процессов.



Средство журналирования
Средство журналирования подобно категории, используемой при регистрации информации.
Средство журналирования принимает значеня auth, authpriv, cron, daemon, kern, lpr, mail, mark, news, syslog, user, UUCP, local0, local1, local2, local3, local4, local5, local6, local7.
Средство журналирования определяется в файле /etc/syslog.conf, /etc/rsyslog.conf или в другом соответсвующем файле, в зависимости от процесса сервера, используемого для ведения журнала в операционной системе на данной UNIX-машине.
Это означает, что, если средство журналирования не определено и, соответсвенно, не поддерживается, отправленные в него журнальные сообщения могут быть проигнорированы и, следовательно, потеряны.



Серверы журналирования
На каждом компьютере с UNIX есть особый серверый процесс, который отвечает за получение журнальных сообщений и запись их в лог-файлы.
Существуют различные разновидности серверов журналирования.
Но только два из них используются в большинстве вариантов UNIX: syslogd(8) и rsyslogd(8).
На большинстве машин с Linux используется rsyslogd(8) - улучшенная и более надежная версия syslogd(8).
Но не взависимости от от нашего варианта UNIX или серверного процесса, используемого для ведения журнала, на всех компьютерах с UNIX журналирование работает одинаково и не влияет на код.
Файл конфигурации rsyslogd(8) обычно называется rsyslog.conf и находится в /etc.



Запись в специальный журнальный файл 
Иногда нужно просто записать журнальные сообщения в выбранный нами файл.
Например, это может понадобиться для записи данных отладки, которые бывают слишком большими.
Или если не хотите записывать их в системные журнальные файлы, а собираетесь хранить данные в собственных журналах, отдельно от системных данных, а потом, допустим, передать их куда-то или сохранить в базе данных.
Или же если хоите хранить свои данные в другом формате



Обработка ошибок в Go
Ошибки и обработка ошибок - две очень важные темы в Go. 
Go любит сообщения об ощибках, что даже имеет особый тип данных для ошибок - error.
Также это означает, что мы сами можем создавать собственные сообщения об ошибках.
Не все ошибочные состояния одинаковы, для одних может потребовтаь немедленная остановка программы, а в других можно ограничиться выводом предупреждающего сообщения для пользователя и продолжить выполнение программы.



Обработка ошибок 
Обрабокта ошибок является очень важной частью Go.
Так как почти все функции возвращают сообщение об ошибке или nil, у Go есть способ сообщить, вознило ли состояние ошибки при выполнении функции.
if err != nil {
    fmt.Println(err)
    os.Exit(10)
}
ВНИМАНИЕ! Не стоит путать обработку ошибок, сопровождаемую выводом сообщений, с выводом сообщения в стандартный поток вывода ошибок: это разные вещи!  
          Первая из них связана с Go кодом, который обрабатывает ошибки 
          Вторая с записиью чего-либо в стандартный дескриптор файла ошибок.
Представленный выше пример кода выводит сгенерированное сообщение об ошибке на экран и выходит из программы посредством функции os.Exit().
Стоит обратить внимание, чтобы выйти из программы, можно также поставить ключевое слово return внутри функции main()
Вообще, вызов функции os.Exit() из функции, если это только не main() считается плохой практикой.
Функции отличные от main(), как правило, перед выходом возвращают сообщение об ошибке, которое обрабатывается вызывающей функцией.
Если есть необходимость отправить сообщение об ошибке не на экран, а в службу журналирования, нужно немного изменить представленный выше код:
    if err != nil {
        log.Println(err)
        os.Exit(10)
    }
Есть и иной вариант этого кода, который используется, когда случается что-то очень плохое и вы хотите срочно завершить программу:
    if err != nil {
        panic(err)
        os.Exit(10)
    }
Panic - это встроенная Go-функция, которая останавливает выполнение программы и начинает паниковать!
Лучше избегать ситуации паники, по возможности заменяя ее обработкой ошибок.
